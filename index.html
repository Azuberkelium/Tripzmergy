<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3s Merge Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Arial', sans-serif;
            color: #ecf0f1;
            flex-direction: column;
            user-select: none;
            overflow: hidden;
        }
        canvas {
            border: 2px solid #ecf0f1;
            background-color: #34495e;
            touch-action: none;
        }
        .info-panel {
            text-align: center;
            margin-bottom: 20px;
        }
        .instructions {
            margin-top: 20px;
            font-size: 1.1em;
            text-align: center;
        }
        .game-over-overlay, .level-up-overlay, .power-up-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2;
            text-align: center;
        }
        .game-over-overlay button, .level-up-overlay button, .power-up-overlay button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            border: 2px solid #ecf0f1;
            background-color: #3498db;
            color: #ecf0f1;
            border-radius: 5px;
        }
        #combo-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #e74c3c;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 3;
        }
        #combo-message.show {
            opacity: 1;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
            gap: 5px;
        }
        .controls button {
            background-color: #34495e;
            color: #ecf0f1;
            border: 2px solid #ecf0f1;
            padding: 15px 15px;
            font-size: 1.5em;
            cursor: pointer;
            border-radius: 8px;
            outline: none;
            transition: background-color 0.2s;
            width: 50px;
            text-align: center;
        }
        .controls button:hover {
            background-color: #4a6681;
        }
        .power-up-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .power-up-buttons button {
            background-color: #2ecc71;
            color: #fff;
            border: none;
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>

    <div class="info-panel">
        <h1>3s Merge Game</h1>
        <p>Your current score: <span id="score">0</span></p>
        <p>Swaps: <span id="swapCount">1</span> | Hammers: <span id="hammerCount">0</span></p>
    </div>

    <canvas id="gameCanvas" width="250" height="400"></canvas>

    <div class="controls">
        <button id="double-left-btn">⏪</button>
        <button id="left-btn">◀️</button>
        <button id="down-btn">⬇️</button>
        <button id="right-btn">▶️</button>
        <button id="double-right-btn">⏩</button>
    </div>

    <div class="power-up-buttons">
        <button id="swap-btn">Use Swap</button>
        <button id="hammer-btn">Use Hammer</button>
    </div>

    <div class="instructions">
        <p>Swipe on the board to move and drop.</p>
    </div>
    
    <div id="combo-message">COMBO!</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const swapCountDisplay = document.getElementById('swapCount');
        const hammerCountDisplay = document.getElementById('hammerCount');
        const comboMessage = document.getElementById('combo-message');
        const swapButton = document.getElementById('swap-btn');
        const hammerButton = document.getElementById('hammer-btn');

        const TILE_SIZE = 50;
        const COLUMNS = 5;
        const ROWS = 8;
        canvas.width = COLUMNS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        let grid = [];
        let score = 0;
        let activePiece = null;
        let lastDropTime = 0;
        const dropInterval = 1000;
        let swapCount = 1;
        let hammerCount = 0;
        let highestBlock = 0;
        let level = 1;
        const allPossibleValues = [3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323];
        let dropValues = [3, 9, 27];
        let lastThreeDrops = [];
        let gamePaused = false;
        
        const numberColors = new Map([
            [3, '#ff6347'], [9, '#ffa500'], [27, '#ffd700'], [81, '#adff2f'],
            [243, '#00bfff'], [729, '#4169e1'], [2187, '#8a2be2'], [6561, '#ff1493'],
            [19683, '#9acd32'], [59049, '#8338ec'], [177147, '#f4a261'],
            [531441, '#e63946'], [1594323, '#2a9d8f']
        ]);
        const textColors = new Map([
            [3, '#fff'], [9, '#000'], [27, '#000'], [81, '#000'],
            [243, '#000'], [729, '#fff'], [2187, '#fff'], [6561, '#fff'],
            [19683, '#000'], [59049, '#fff'], [177147, '#000'],
            [531441, '#fff'], [1594323, '#000']
        ]);
        
        function createGrid() {
            grid = Array(ROWS).fill(null).map(() => Array(COLUMNS).fill(null));
        }

        function createPiece() {
            const startX = Math.floor(COLUMNS / 2);
            if (grid[0][startX]) {
                gameOver("No more space for new blocks!");
                return;
            }

            let randomValue;
            do {
                randomValue = dropValues[Math.floor(Math.random() * dropValues.length)];
            } while (lastThreeDrops.filter(v => v === randomValue).length >= 2);
            
            lastThreeDrops.push(randomValue);
            if (lastThreeDrops.length > 3) {
                lastThreeDrops.shift();
            }

            activePiece = {
                x: startX,
                y: 0,
                value: randomValue,
                color: numberColors.get(randomValue) || '#ccc'
            };
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLUMNS; x++) {
                    if (grid[y][x]) {
                        drawSquare(x, y, grid[y][x].color, grid[y][x].value);
                    }
                }
            }
        }

        function drawSquare(x, y, color, text) {
            ctx.fillStyle = color;
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#2c3e50';
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

            ctx.fillStyle = textColors.get(text) || '#ecf0f1';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
        }

        function drawPiece() {
            if (activePiece) {
                drawSquare(activePiece.x, activePiece.y, activePiece.color, activePiece.value);
            }
        }
        
        function movePiece(dx) {
            const newX = activePiece.x + dx;
            if (newX >= 0 && newX < COLUMNS && !grid[activePiece.y][newX]) {
                activePiece.x = newX;
            }
        }

        function dropPiece() {
            let newY = activePiece.y;
            while (newY + 1 < ROWS && !grid[newY + 1][activePiece.x]) {
                newY++;
            }
            activePiece.y = newY;
            placePiece();
        }

        function placePiece() {
            if (activePiece.y >= 0) {
                grid[activePiece.y][activePiece.x] = activePiece;
                activePiece = null;
                checkAndMerge();
            }
        }

        function showComboMessage() {
            comboMessage.classList.add('show');
            setTimeout(() => {
                comboMessage.classList.remove('show');
            }, 1000);
        }
        
        function checkForNewHighest(newValue) {
            if (newValue > highestBlock) {
                highestBlock = newValue;
                level++;
                
                const reward = Math.random() < 0.5 ? 'swap' : 'hammer';
                if (reward === 'swap') {
                    swapCount++;
                } else {
                    hammerCount++;
                }
                
                updatePowerUpButtons();
                levelUp();
            }
        }

        function levelUp() {
            const highestBlockIndex = allPossibleValues.indexOf(highestBlock);
            const highestDroppableIndex = highestBlockIndex > 0 ? highestBlockIndex - 1 : 0;
            
            const newDropValues = allPossibleValues.slice(0, highestDroppableIndex + 1);
            dropValues = newDropValues;

            const newHighestDroppableValue = dropValues[dropValues.length - 1];
            
            pauseGame();
            showLevelUpPopUp(highestBlock, newHighestDroppableValue);
        }
        
        function pauseGame() {
            gamePaused = true;
        }

        function resumeGame() {
            gamePaused = false;
            requestAnimationFrame(gameLoop);
        }

        function showLevelUpPopUp(newHighest, newHighestDroppable) {
            const overlay = document.createElement('div');
            overlay.className = 'level-up-overlay';
            overlay.innerHTML = `
                <h2>Level Up!</h2>
                <p>You created a **${newHighest}** block!</p>
                <p>The new highest block that can drop is **${newHighestDroppable}**.</p>
                <p>You earned a new power-up!</p>
                <button id="closeLevelUp">Continue</button>
            `;
            document.body.appendChild(overlay);

            document.getElementById('closeLevelUp').onclick = () => {
                document.body.removeChild(overlay);
                updateScore();
                resumeGame();
            };
        }

        function checkAndMerge() {
            let merged = true;
            let comboChain = 0;
            while (merged) {
                merged = false;
                let mergeOccurred = false;
                const cellsToClear = new Set();
                const newMerges = [];

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLUMNS; x++) {
                        if (grid[y][x] && !cellsToClear.has(`${x},${y}`)) {
                            const value = grid[y][x].value;
                            
                            if (y < ROWS - 2 && grid[y+1][x] && grid[y+1][x].value === value && grid[y+2][x] && grid[y+2][x].value === value) {
                                newMerges.push({ x, y: y+2, value: value * 3 });
                                cellsToClear.add(`${x},${y}`);
                                cellsToClear.add(`${x},${y+1}`);
                                cellsToClear.add(`${x},${y+2}`);
                                mergeOccurred = true;
                            }
                            if (x < COLUMNS - 2 && grid[y][x+1] && grid[y][x+1].value === value && grid[y][x+2] && grid[y][x+2].value === value) {
                                newMerges.push({ x: x+2, y, value: value * 3 });
                                cellsToClear.add(`${x},${y}`);
                                cellsToClear.add(`${x+1},${y}`);
                                cellsToClear.add(`${x+2},${y}`);
                                mergeOccurred = true;
                            }
                            if (x < COLUMNS - 2 && y < ROWS - 2 && grid[y+1][x+1] && grid[y+1][x+1].value === value && grid[y+2][x+2] && grid[y+2][x+2].value === value) {
                                newMerges.push({ x: x+2, y: y+2, value: value * 3 });
                                cellsToClear.add(`${x},${y}`);
                                cellsToClear.add(`${x+1},${y+1}`);
                                cellsToClear.add(`${x+2},${y+2}`);
                                mergeOccurred = true;
                            }
                            if (x > 1 && y < ROWS - 2 && grid[y+1][x-1] && grid[y+1][x-1].value === value && grid[y+2][x-2] && grid[y+2][x-2].value === value) {
                                newMerges.push({ x: x-2, y: y+2, value: value * 3 });
                                cellsToClear.add(`${x},${y}`);
                                cellsToClear.add(`${x-1},${y+1}`);
                                cellsToClear.add(`${x-2},${y+2}`);
                                mergeOccurred = true;
                            }
                        }
                    }
                }
                
                if (mergeOccurred) {
                    comboChain++;
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLUMNS; x++) {
                            if (cellsToClear.has(`${x},${y}`)) {
                                grid[y][x] = null;
                            }
                        }
                    }

                    newMerges.forEach(merge => {
                        checkForNewHighest(merge.value);
                        const newColor = numberColors.get(merge.value) || '#ccc';
                        grid[merge.y][merge.x] = {
                            x: merge.x,
                            y: merge.y,
                            value: merge.value,
                            color: newColor
                        };
                        score += merge.value;
                    });
                    
                    merged = true;
                    applyGravity();
                }
            }
            if (comboChain > 1) {
                showComboMessage();
            }
            updateScore();
        }

        function applyGravity() {
            for (let x = 0; x < COLUMNS; x++) {
                let writeY = ROWS - 1;
                for (let y = ROWS - 1; y >= 0; y--) {
                    if (grid[y][x]) {
                        if (y !== writeY) {
                            grid[writeY][x] = grid[y][x];
                            grid[y][x] = null;
                            grid[writeY][x].y = writeY;
                        }
                        writeY--;
                    }
                }
            }
        }

        function updateScore() {
            scoreDisplay.textContent = score;
            swapCountDisplay.textContent = swapCount;
            hammerCountDisplay.textContent = hammerCount;
            updatePowerUpButtons();
        }

        function updatePowerUpButtons() {
            swapButton.style.display = swapCount > 0 ? 'inline-block' : 'none';
            hammerButton.style.display = hammerCount > 0 ? 'inline-block' : 'none';
        }

        function gameOver(message) {
            const existingOverlay = document.querySelector('.game-over-overlay');
            if (existingOverlay) return;

            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            overlay.innerHTML = `
                <h2>Game Over!</h2>
                <p>${message}</p>
                <p>Final Score: ${score}</p>
                <p>Final Level: ${level}</p>
                <button id="restartButton">Restart Game</button>
                <button id="shareButton">Share Score</button>
            `;
            document.body.appendChild(overlay);

            const restartButton = document.getElementById('restartButton');
            restartButton.onclick = () => {
                document.body.removeChild(overlay);
                resetGame();
            };

            const shareButton = document.getElementById('shareButton');
            shareButton.onclick = () => {
                const shareText = `I got a score of ${score} and reached level ${level} in 3s Merge! Can you beat me?`;
                if (navigator.share) {
                    navigator.share({
                        title: '3s Merge Game',
                        text: shareText
                    });
                } else if (navigator.clipboard) {
                    navigator.clipboard.writeText(shareText).then(() => {
                        alert('Score copied to clipboard!');
                    });
                } else {
                    alert('Sharing not supported on this browser.');
                }
            };

            activePiece = null;
            gamePaused = true;
        }

        let isSwapMode = false;
        let isHammerMode = false;
        let selectedBlock1 = null;

        function startSwapMode() {
            if (swapCount > 0 && !isSwapMode && !isHammerMode && activePiece) {
                pauseGame();
                isSwapMode = true;
                swapCount--;
                updateScore();
                alert("Swap mode: Click two blocks to swap them!");
            }
        }

        function startHammerMode() {
            if (hammerCount > 0 && !isHammerMode && !isSwapMode && activePiece) {
                pauseGame();
                isHammerMode = true;
                hammerCount--;
                updateScore();
                alert("Hammer mode: Click a block to remove it!");
            }
        }

        function handleCanvasClick(e, touchEvent) {
            if (!gamePaused && !isSwapMode && !isHammerMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const clientX = touchEvent ? e.touches[0].clientX : e.clientX;
            const clientY = touchEvent ? e.touches[0].clientY : e.clientY;
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const gridX = Math.floor(x / TILE_SIZE);
            const gridY = Math.floor(y / TILE_SIZE);

            if (gridY < 0 || gridY >= ROWS || gridX < 0 || gridX >= COLUMNS) return;

            if (isSwapMode) {
                const block = grid[gridY][gridX];
                if (block) {
                    if (!selectedBlock1) {
                        selectedBlock1 = { x: gridX, y: gridY };
                        drawSelection(gridX, gridY);
                    } else {
                        const block2 = { x: gridX, y: gridY };
                        swapBlocks(selectedBlock1, block2);
                        isSwapMode = false;
                        selectedBlock1 = null;
                        checkAndMerge();
                        resumeGame();
                    }
                }
            } else if (isHammerMode) {
                if (grid[gridY][gridX]) {
                    grid[gridY][gridX] = null;
                    isHammerMode = false;
                    applyGravity();
                    checkAndMerge();
                    resumeGame();
                }
            }
        }

        canvas.addEventListener('mousedown', (e) => handleCanvasClick(e, false));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleCanvasClick(e, true);
        });

        function drawSelection(x, y) {
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 3;
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.lineWidth = 1;
        }

        function swapBlocks(block1, block2) {
            const temp = grid[block1.y][block1.x];
            grid[block1.y][block1.x] = grid[block2.y][block2.x];
            grid[block2.y][block2.x] = temp;
            if (grid[block1.y][block1.x]) grid[block1.y][block1.x].y = block1.y;
            if (grid[block2.y][block2.x]) grid[block2.y][block2.x].y = block2.y;
            applyGravity();
        }

        function resetGame() {
            score = 0;
            swapCount = 1;
            hammerCount = 0;
            highestBlock = 0;
            level = 1;
            dropValues = [3, 9, 27];
            lastThreeDrops = [];
            updateScore();
            createGrid();
            isSwapMode = false;
            isHammerMode = false;
            selectedBlock1 = null;
            resumeGame();
        }

        document.getElementById('double-left-btn').addEventListener('click', () => {
            if (activePiece && !gamePaused) movePiece(-2);
        });
        document.getElementById('left-btn').addEventListener('click', () => {
            if (activePiece && !gamePaused) movePiece(-1);
        });
        document.getElementById('right-btn').addEventListener('click', () => {
            if (activePiece && !gamePaused) movePiece(1);
        });
        document.getElementById('double-right-btn').addEventListener('click', () => {
            if (activePiece && !gamePaused) movePiece(2);
        });
        document.getElementById('down-btn').addEventListener('click', () => {
            if (activePiece && !gamePaused) dropPiece();
        });

        swapButton.addEventListener('click', startSwapMode);
        hammerButton.addEventListener('click', startHammerMode);

        let touchstartX = 0;
        let touchendX = 0;
        let touchstartY = 0;
        let touchendY = 0;

        function handleGesture() {
            if (gamePaused || isSwapMode || isHammerMode || !activePiece) return;

            const dx = touchendX - touchstartX;
            const dy = touchendY - touchstartY;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
                if (dx > 0) movePiece(1);
                else movePiece(-1);
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 30) {
                if (dy > 0) dropPiece();
            }
        }

        canvas.addEventListener('touchstart', e => {
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
        });

        canvas.addEventListener('touchend', e => {
            touchendX = e.changedTouches[0].screenX;
            touchendY = e.changedTouches[0].screenY;
            handleGesture();
        });

        document.addEventListener('keydown', (e) => {
            if (gamePaused || isSwapMode || isHammerMode || !activePiece) return;
            switch (e.key) {
                case 'ArrowLeft':
                    movePiece(-1);
                    break;
                case 'ArrowRight':
                    movePiece(1);
                    break;
                case 'ArrowDown':
                    dropPiece();
                    break;
            }
        });

        function gameLoop(timestamp) {
            if (gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            if (isSwapMode || isHammerMode) {
                drawGrid();
                if (selectedBlock1) {
                    drawSelection(selectedBlock1.x, selectedBlock1.y);
                }
                requestAnimationFrame(gameLoop);
                return;
            }

            if (!activePiece) {
                createPiece();
                if (!activePiece) {
                    gameOver("No space to add new blocks!");
                    return;
                }
            }

            if (timestamp - lastDropTime > dropInterval) {
                if (activePiece.y + 1 < ROWS && !grid[activePiece.y + 1][activePiece.x]) {
                    activePiece.y++;
                } else {
                    placePiece();
                }
                lastDropTime = timestamp;
            }

            drawGrid();
            if (activePiece) {
                drawPiece();
            }
            requestAnimationFrame(gameLoop);
        }

        resetGame();
    </script>
</body>
</html>
